2c2
< // "subgenelife.c"
---
> // "subgenelife.h"
8c8
< // Copyright Â© 2017,2018,2019 European Center for Living Technology. All rights reserved.
---
> // Copyright 2017,2018,2019 European Center for Living Technology. All rights reserved.
228a229
> // #include "genelife_size.h"
230c231
< /* const int log2N = 7;                // toroidal array of side length N = 2 to the power of log2N (minimum log2N is 6 i.e. 64x64)
---
> const int log2N = 7;                // toroidal array of side length N = 2 to the power of log2N (minimum log2N is 6 i.e. 64x64)
235,236c236
< const int NLM = N2;  */
< #include "genelife_size.h"
---
> const int NLM = N2;                 // maximum number of discrete components possible N*N
483,484c483
< uint64_t clonealogytrace[N2];       // image trace of clonealogies for N most frequently populated clones
< const int nNhist = 20;              // maximum number of older blocks for trace
---
> uint64_t clonealogytrace[N2];       // image trace of clonealogies for N most frequently populated clones          
486,489c485,493
< uint64_t poptrace1[N2*nNhist];      // trace of first N*nNhist time points of population of N most frequent genes
< uint64_t acttrace1[N2*nNhist];      // trace of first N*nNhist time points of activity of N most frequent genes
< uint64_t acttraceq1[N2*nNhist];     // trace of first N*nNhist time points of activity of N most frequent quad patterns
< unsigned char acttraceqt1[N2*nNhist];// type of entry in acttraceq : 1 quad, 0 smallpatt (<65536) i.e. corresponding to isnode
---
> enum {nNhist = 20,					// maximum number of older blocks for trace
> 	  N2h = N2*nNhist,
>       Nh = N*nNhist,
>   	  log2N1 = log2N+1,
>   	  N1 = N+1};
> uint64_t poptrace1[N2h];      		// trace of first N*nNhist time points of population of N most frequent genes
> uint64_t acttrace1[N2h];      		// trace of first N*nNhist time points of activity of N most frequent genes
> uint64_t acttraceq1[N2h];     		// trace of first N*nNhist time points of activity of N most frequent quad patterns
> unsigned char acttraceqt1[N2h];		// type of entry in acttraceq : 1 quad, 0 smallpatt (<65536) i.e. corresponding to isnode
492,493c496,497
< int npopulation1[N*nNhist];         // number of live sites (gol 1s) in first N*nNhist time steps
< unsigned int nnovelcells[N*nNhist]; // number of live sites that are part of novel components in first N*nNhist time steps
---
> int npopulation1[Nh];         		// number of live sites (gol 1s) in first N*nNhist time steps
> unsigned int nnovelcells[Nh]; 		// number of live sites that are part of novel components in first N*nNhist time steps
498,499c502,503
< int histcumlogpattsize[log2N+1];    // histogram of patterns binned on log scale according to power of two side enclosing square
< int histcumpixelssqrt[N+1];         // histogram of patterns binned on an integer sqrt scale according to number of pixels
---
> int histcumlogpattsize[log2N1];     // histogram of patterns binned on log scale according to power of two side enclosing square
> int histcumpixelssqrt[N1];          // histogram of patterns binned on an integer sqrt scale according to number of pixels
501,502c505,506
< // const int NLM = N2;                 // maximum number of discrete components possible N*N: formerly N*N/4 but needed expansion upon intro of genetic diff comp's
< const int NLC = N2<<2;              // maximum number of connections N*N*4
---
> // enum { NLM = N2};                // maximum number of discrete components possible N*N: formerly N*N/4 but needed expansion upon intro of genetic diff comp's
> enum { NLC = N2<<2};                // maximum number of connections N*N*4
2397,2398c2401,2404
<         if(nw) hash_patt4_find(nw);if(ne) hash_patt4_find(ne);   // find or store 8x8 64-bit subpatterns, updating activities and lasttime
<         if(sw) hash_patt4_find(sw);if(se) hash_patt4_find(se);   // store if new, otherwise update
---
>         if(nw) hash_patt4_find(nw);   // find or store 8x8 64-bit subpatterns, updating activities and lasttime
>         if(ne) hash_patt4_find(ne);   // store if new, otherwise update
>         if(sw) hash_patt4_find(sw);
>         if(se) hash_patt4_find(se);
2430c2436
<         quadnode *q,*q8;
---
>         quadnode *q;
2468,2471c2474,2477
<         if(nw) q8 = hash_patt8_find(nw);                        // find or store 8x8 64-bit subpatterns, updating activities and lasttime
<         if(ne) q8 = hash_patt8_find(ne);                        // store if new, otherwise update.
<         if(sw) q8 = hash_patt8_find(sw);                        // note that value q8 is never used in this routine, this is intended.
<         if(se) q8 = hash_patt8_find(se);
---
>         if(nw) (void) hash_patt8_find(nw);                        // find or store 8x8 64-bit subpatterns, updating activities and lasttime
>         if(ne) (void) hash_patt8_find(ne);                        // store if new, otherwise update.
>         if(sw) (void) hash_patt8_find(sw);
>         if(se) (void) hash_patt8_find(se);
4522c4528
< void update_lut_2D_sym(uint64_t gol[], uint64_t golg[], uint64_t golgstats[], uint64_t golb[], uint64_t golr[], uint64_t newgol[], uint64_t newgolg[], uint64_t newgolgstats[], uint64_t newgolb[], uint64_t newgolr[]) {     // selection models 14,15
---
> void update_lut_2D_sym(uint64_t gol[], uint64_t golg[], uint64_t golgstats[], uint64_t golb[],uint64_t golr[],uint64_t newgol[], uint64_t newgolg[], uint64_t newgolgstats[], uint64_t newgolb[],uint64_t newgolr[]) {     // selection models 14,15
4554d4559
< 
4572a4578
> 
4729c4735
<     int k,t,npop;
---
>     int k,t;
4771c4777
<         if (diagnostics & diag_scrolling_trace) npop = totalpoptrace(gol);    // calculate total current population and store in scrolling trace npopulation
---
>         if (diagnostics & diag_scrolling_trace) totalpoptrace(gol);    // calculate total current population and store in scrolling trace npopulation
5023c5029,5030
<                  for (k=0;k<8;k++)   startgenes[k] = ((0x7ull>>(k&3))<<61) | genegol[selection-8];break;    // put up to 3 extra bits at top to ensure all nr 1s values occupied
---
>                  for (k=0;k<8;k++)   startgenes[k] = ((0x7ull>>(k&3))<<61) | genegol[selection-8];          // put up to 3 extra bits at top to ensure all nr 1s values occupied
>                  break;
5026c5033,5034
<                  for (k=0;k<8;k++)   startgenes[k] = ((0x7ull>>(k&3))<<61) | genegol[selection-8];break;    // put up to 3 extra bits at top to ensure all nr 1s values occupied
---
>                  for (k=0;k<8;k++)   startgenes[k] = ((0x7ull>>(k&3))<<61) | genegol[selection-8];          // put up to 3 extra bits at top to ensure all nr 1s values occupied
>                  break;
5029c5037,5038
<                  for (k=0;k<8;k++)   startgenes[k] = ((0x7ull>>(k&3))<<61) | genegol[selection-8];break;
---
>                  for (k=0;k<8;k++)   startgenes[k] = ((0x7ull>>(k&3))<<61) | genegol[selection-8];
>                  break;
5032c5041,5042
<                  for (k=0;k<8;k++)   startgenes[k] = ((0x7ull>>(k&3))<<61) | genegol[selection-8];break;
---
>                  for (k=0;k<8;k++)   startgenes[k] = ((0x7ull>>(k&3))<<61) | genegol[selection-8];
>                  break;
5035c5045,5046
<                  for (k=0;k<8;k++)   startgenes[k] = ((0x7ull>>(k&3))<<61) | genegol[selection-8];break;
---
>                  for (k=0;k<8;k++)   startgenes[k] = ((0x7ull>>(k&3))<<61) | genegol[selection-8];
>                  break;
5038c5049,5050
<                  for (k=0;k<8;k++)   startgenes[k] = ((0x7ull>>(k&3))<<61) | genegol[selection-8];break;
---
>                  for (k=0;k<8;k++)   startgenes[k] = ((0x7ull>>(k&3))<<61) | genegol[selection-8];
>                  break;
5041c5053,5054
<                  for (k=0;k<8;k++)   startgenes[k] = ((0x7ull>>(k&3))<<61) | genegol[selection-8];break;
---
>                  for (k=0;k<8;k++)   startgenes[k] = ((0x7ull>>(k&3))<<61) | genegol[selection-8];
>                  break;
5044c5057,5058
<                  for (k=0;k<8;k++)   startgenes[k] = ((0x7ull>>(k&3))<<61) | genegol[selection-8];break;
---
>                  for (k=0;k<8;k++)   startgenes[k] = ((0x7ull>>(k&3))<<61) | genegol[selection-8];
>                  break;
6212a6227
>             j++;
6214d6228
<         // gindices[j++] = (geneitems[i].popcount) ? i : gindices[j--];   // if col is 0 then the array gindices must be passed with sufficient length
6364c6378
<     int qsindices[65536]; // ,qsallindices[65536];
---
>     int qsindices[65536]; //,qsallindices[65536];
6510c6524,6525
<             gindices[j++]=i;
---
>             gindices[j]=i;
>             j++;
6690c6705,6706
<             gindices[j++]=i;
---
>             gindices[j]=i;
>             j++;
